{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["/*\n * Created with @iobroker/create-adapter v2.0.1\n */\n\n// The adapter-core module gives you access to the core ioBroker functions\n// you need to create an adapter\nimport * as utils from '@iobroker/adapter-core';\n\n// Load your modules here, e.g.:\n// import * as fs from \"fs\";\nimport { libdsvdc } from 'libdsvdcts';\nimport { rgbhelper } from 'rgbhelper';\n\nclass DigitalstromVdc extends utils.Adapter {\n    vdc: any;\n    setOutputChannel: Array<any> = [];\n    allDevices: any = [];\n\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({\n            ...options,\n            name: 'digitalstrom-vdc',\n        });\n        this.on('ready', this.onReady.bind(this));\n        this.on('stateChange', this.onStateChange.bind(this));\n        this.on('objectChange', this.onObjectChange.bind(this));\n        this.on('message', this.onMessage.bind(this));\n        this.on('unload', this.onUnload.bind(this));\n        this.allDevices = [];\n    }\n\n    /**\n     * Is called when databases are connected and adapter received configuration.\n     */\n    private async onReady(): Promise<void> {\n        // Initialize your adapter here\n\n        // The adapters config (in the instance object everything under the attribute \"native\") is accessible via\n        // this.config:\n        /* this.log.info(\"config option1: \" + this.config.option1);\n        this.log.info(\"config option2: \" + this.config.option2);\n        this.log.info(\"config option3: \" + this.config.dsDevices);\n        this.log.info(\"config option3: \" + this.config.vdcName); */\n\n        this.setState('info.connection', false, true);\n\n        /*\n        For every state in the system there has to be also an object of type state\n        Here a simple template for a boolean variable named \"testVariable\"\n        Because every adapter instance uses its own unique namespace variable names can't collide with other adapters variables\n        */\n        await this.setObjectNotExistsAsync('DS-Devices.VDC.running', {\n            type: 'state',\n            common: {\n                name: 'running',\n                type: 'boolean',\n                role: 'indicator',\n                read: true,\n                write: true,\n            },\n            native: {\n                Name: 'running',\n            },\n        });\n\n        /* this.allDevices = await this.getObjectListAsync(null).then((devices) => {\n            this.log.debug(`OBJECT OBJECT OBJECT \\n\\n\\n ${JSON.stringify(devices)}`);\n            return devices;\n        });*/\n\n        this.allDevices = await this.refreshDeviceList();\n\n        const dsDevices: Array<any> = [];\n        this.allDevices.forEach((d: any) => {\n            this.log.info(JSON.stringify(d.native.deviceObj.dsConfig));\n            console.log(JSON.stringify(d.native.deviceObj.dsConfig));\n            if (typeof d.native.deviceObj.watchStateID == 'object') {\n                for (const [key, value] of Object.entries(d.native.deviceObj.watchStateID)) {\n                    this.log.debug(`subscribing to ${key} / ${value}`);\n                    this.subscribeForeignStates(value as string);\n                }\n            } else if (d.native.deviceObj.watchStateID && d.native.deviceObj.watchStateID.length > 0) {\n                this.log.debug(`subscribing to ${d.native.deviceObj.watchStateID}`);\n                this.subscribeForeignStates(d.native.deviceObj.watchStateID);\n            }\n            if (d.native.deviceObj.dsConfig) {\n                this.log.debug(`Pushing ${JSON.stringify(d.native.deviceObj.dsConfig)} to devices`);\n                dsDevices.push(d.native.deviceObj.dsConfig);\n            }\n        });\n\n        // In order to get state updates, you need to subscribe to them. The following line adds a subscription for our variable we have created above.\n        // this.subscribeStates(\"testVariable\");\n        // You can also add a subscription for multiple states. The following line watches all states starting with \"lights.\"\n        // this.subscribeStates(\"lights.*\");\n        // Or, if you really must, you can also watch all states. Don't do this if you don't need to. Otherwise this will cause a lot of unnecessary load on the system:\n        // this.subscribeStates(\"*\");\n\n        /*\n\t\t\tsetState examples\n\t\t\tyou will notice that each setState will cause the stateChange event to fire (because of above subscribeStates cmd)\n\t\t*/\n        // the variable testVariable is set to true as command (ack=false)\n        // await this.setStateAsync(\"testVariable\", true);\n\n        // same thing, but the value is flagged \"ack\"\n        // ack should be always set to true if the value is received from or acknowledged from the target system\n        // await this.setStateAsync(\"testVariable\", { val: true, ack: true });\n\n        // same thing, but the state is deleted after 30s (getState will return null afterwards)\n        // await this.setStateAsync(\"testVariable\", { val: true, ack: true, expire: 30 });\n\n        // examples for the checkPassword/checkGroup functions\n        /* let result = await this.checkPasswordAsync(\"admin\", \"iobroker\");\n        this.log.info(\"check user admin pw iobroker: \" + result);\n\n        result = await this.checkGroupAsync(\"admin\", \"admin\");\n        this.log.info(\"check group user admin group admin: \" + result);*/\n\n        this.log.debug(`dsDevices: ${JSON.stringify(this.allDevices)}`);\n\n        const vdc = new libdsvdc({ debug: this.config.vdcDebug });\n\n        if (\n            this.config.vdcName &&\n            this.config.vdcName.length > 0 &&\n            this.config.vdcDSUID &&\n            this.config.vdcDSUID.length > 0 &&\n            this.config.vdcPort\n        ) {\n            vdc.start(\n                {\n                    vdcName: this.config.vdcName,\n                    vdcDSUID: this.config.vdcDSUID,\n                    port: this.config.vdcPort,\n                    configURL: this.config.vdcConfigURL,\n                },\n                dsDevices,\n            );\n        }\n\n        this.vdc = vdc;\n\n        vdc.on('messageReceived', (msg: JSON) => {\n            this.log.debug(`MSG RECEIVED\" ${JSON.stringify(msg)}`);\n        });\n\n        vdc.on('messageSent', (msg: JSON) => {\n            this.log.debug(`MSG SENT\" ${JSON.stringify(msg)}`);\n        });\n\n        vdc.on('VDSM_NOTIFICATION_SET_CONTROL_VALUE', (msg: any) => {\n            this.log.info(`received control value ${JSON.stringify(msg)}`);\n            if (msg && msg.name) {\n                if (msg && msg.dSUID) {\n                    msg.dSUID.forEach((id: string) => {\n                        const affectedDevice = this.allDevices.find(\n                            (d: any) => d.dsConfig.dSUID.toLowerCase() == id.toLowerCase(),\n                        );\n                        if (affectedDevice) {\n                            // found the device -> it's an update for the device\n                            if (affectedDevice.deviceType == 'rgbLamp') {\n                                // it's an update for an rgb lamp\n                                if (msg.channelId == 'x' || msg.channelId == 'y') {\n                                    // we have an CIE situation here\n                                } else {\n                                    const affectedState = affectedDevice.watchStateID[msg.channelId];\n                                    if (affectedState) {\n                                        this.log.info(\n                                            `Received an update for state ${affectedState} in device ${affectedDevice.name} with value ${msg.value}`,\n                                        );\n                                        this.setForeignStateAsync(affectedState, {\n                                            val: msg.value,\n                                            ack: false,\n                                        }).then((error) => {\n                                            this.log.info(`set ${affectedState} ${error}`);\n                                        });\n                                    }\n                                }\n                            }\n                        } else if (msg.name === 'TemperatureOutside') {\n                            this.setStateAsync('DS-Devices.outdoorValues.temperature', {\n                                val: msg.value,\n                                ack: true,\n                            }).then((error) => {\n                                this.log.info(`set temperature ${error}`);\n                            });\n                        } else if (msg.name === 'BrightnessOutside') {\n                            this.setStateAsync('DS-Devices.outdoorValues.brightness', {\n                                val: msg.value,\n                                ack: true,\n                            }).then((error) => {\n                                this.log.info(`set brightness ${error}`);\n                            });\n                        }\n                    });\n                }\n            }\n        });\n\n        vdc.on('VDSM_NOTIFICATION_SET_OUTPUT_CHANNEL_VALUE', (msg: any) => {\n            this.log.info(`received OUTPUTCHANNELVALUE value ${JSON.stringify(msg)}`);\n\n            if (msg && msg.dSUID) {\n                msg.dSUID.forEach((id: string) => {\n                    const affectedDevice = this.allDevices.find(\n                        (d: any) => d.dsConfig.dSUID.toLowerCase() == id.toLowerCase(),\n                    );\n                    if (affectedDevice) {\n                        // found the device -> it's an update for the device\n                        if (affectedDevice.deviceType == 'rgbLamp') {\n                            // it's an update for an rgb lamp\n                            if (msg.channelId == 'x' || msg.channelId == 'y') {\n                                // we have an CIE situation here\n                            } else {\n                                const affectedState = affectedDevice.watchStateID[msg.channelId];\n                                if (affectedState) {\n                                    this.log.info(\n                                        `Received an update for state ${affectedState} in device ${affectedDevice.name} with value ${msg.value} and ${msg.applyNow}`,\n                                    );\n                                    this.setOutputChannel.push({\n                                        name: msg.channelId,\n                                        state: affectedState,\n                                        value: msg.value,\n                                    });\n                                    if (msg.applyNow) {\n                                        this.setOutputChannel.push({\n                                            name: msg.channelId,\n                                            state: affectedState,\n                                            value: msg.value,\n                                        });\n\n                                        const sat = this.setOutputChannel.find((v) => v.name == 'saturation');\n                                        const hue = this.setOutputChannel.find((v) => v.name == 'hue');\n                                        const brightness = this.setOutputChannel.find((v) => v.name == 'brightness');\n                                        const colortemp = this.setOutputChannel.find((v) => v.name == 'colortemp');\n\n                                        if (sat && hue && brightness) {\n                                            // all values exist -> let's perform some magic\n                                            this.log.debug(\n                                                `Hue: ${hue.value} Saturation: ${sat.value} Brightness: ${brightness.value}`,\n                                            );\n                                            const rgb = rgbhelper.hsvTOrgb(hue.value, sat.value, brightness.value);\n                                            const rgbHex = rgbhelper.rgbTOhex(rgb);\n\n                                            this.setForeignStateAsync(affectedDevice.watchStateID['rgb'], {\n                                                val: rgbHex,\n                                                ack: false,\n                                            }).then((error) => {\n                                                if (error) {\n                                                    /* this.log.error(\n                                                        `Error performing update of the RGB value (${rgb} / ${rgbHex}) on ${affectedDevice.name} `,\n                                                    ); */\n                                                } else {\n                                                    this.log.info(\n                                                        `Successful update of RGB to ${rgb} / ${rgbHex} on ${affectedDevice.name}`,\n                                                    );\n                                                }\n                                            });\n\n                                            this.setOutputChannel.forEach((c) => {\n                                                this.setForeignStateAsync(c.state, {\n                                                    val: c.value,\n                                                    ack: false,\n                                                }).then((error) => {\n                                                    if (error) {\n                                                        /* this.log.error(\n                                                            `Error performing update of the ${c.name} value (${c.value}) on ${affectedDevice.name} - ${error} `,\n                                                        ); */\n                                                    } else {\n                                                        this.log.info(\n                                                            `Successful update of ${c.name} to ${c.value} on ${affectedDevice.name}`,\n                                                        );\n                                                    }\n                                                });\n                                            });\n\n                                            this.setForeignStateAsync(affectedDevice.watchStateID.switchModeColor, {\n                                                val: true,\n                                                ack: false,\n                                            }).then((error) => {\n                                                if (error) {\n                                                    /* this.log.error(\n                                                        `Error performing update of the colorMode on ${affectedDevice.name} - ${error}`,\n                                                    ); */\n                                                } else {\n                                                    this.log.info(\n                                                        `Successful update of colorMode to false on ${affectedDevice.name}`,\n                                                    );\n                                                }\n                                            });\n                                        } else if (brightness) {\n                                            // only brightness is set -> lets update it\n                                            this.log.debug(`Brightness: ${brightness.value}`);\n\n                                            // turn off / on depending on the brightness\n                                            if (brightness.value == 0) {\n                                                const affectedStateSwitch = affectedDevice.watchStateID['switch'];\n                                                this.setOutputChannel.push({\n                                                    name: 'switch',\n                                                    state: affectedStateSwitch,\n                                                    value: false,\n                                                });\n                                            } else {\n                                                const affectedStateSwitch = affectedDevice.watchStateID['switch'];\n                                                this.setOutputChannel.push({\n                                                    name: 'switch',\n                                                    state: affectedStateSwitch,\n                                                    value: true,\n                                                });\n                                            }\n                                            this.setOutputChannel.forEach((c) => {\n                                                this.setForeignStateAsync(c.state, {\n                                                    val: c.value,\n                                                    ack: false,\n                                                }).then((error) => {\n                                                    if (error) {\n                                                        /* this.log.error(\n                                                            `Error performing update of the ${c.name} value (${c.value}) on ${affectedDevice.name} - ${error}`,\n                                                        ); */\n                                                    } else {\n                                                        this.log.info(\n                                                            `Successful update of ${c.name} to ${c.value} on ${affectedDevice.name}`,\n                                                        );\n                                                    }\n                                                });\n                                            });\n                                        } else if (colortemp) {\n                                            // only colortemp is set -> lets update it and switch color-mode\n                                            this.log.debug(`Colortemp: ${colortemp.value}`);\n                                            const kelvinValue = Math.floor(1000000 / colortemp.value);\n\n                                            this.setForeignStateAsync(affectedDevice.watchStateID.colortemp, {\n                                                val: kelvinValue,\n                                                ack: false,\n                                            }).then((error) => {\n                                                if (error) {\n                                                    /* this.log.error(\n                                                        `Error performing update of the colortemp value (${kelvinValue}) on ${affectedDevice.name} - ${error}`,\n                                                    ); */\n                                                } else {\n                                                    this.log.info(\n                                                        `Successful update of colortemp to ${kelvinValue} on ${affectedDevice.name}`,\n                                                    );\n                                                }\n                                            });\n\n                                            this.setForeignStateAsync(affectedDevice.watchStateID.switchModeColor, {\n                                                val: false,\n                                                ack: false,\n                                            }).then((error) => {\n                                                if (error) {\n                                                    /* this.log.error(\n                                                        `Error performing update of the colorMode on ${affectedDevice.name} - ${error}`,\n                                                    ); */\n                                                } else {\n                                                    this.log.info(\n                                                        `Successful update of colorMode to false on ${affectedDevice.name}`,\n                                                    );\n                                                }\n                                            });\n                                        } else {\n                                            this.log.error(\n                                                `Could not set the color on ${\n                                                    affectedDevice.name\n                                                } because some values where missing inside the buffer ${JSON.stringify(\n                                                    this.setOutputChannel,\n                                                )}`,\n                                            );\n                                        }\n\n                                        // reset buffer again\n                                        this.setOutputChannel = [];\n                                    }\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n        });\n\n        vdc.on('VDSM_NOTIFICATION_SAVE_SCENE', (msg: any) => {\n            this.log.info(`received save scene event ${JSON.stringify(msg)}`);\n            if (msg && msg.dSUID) {\n                msg.dSUID.forEach(async (id: string) => {\n                    // this.log.debug(`searching for ${id} in ${JSON.stringify(this.config.dsDevices)}`);\n                    const affectedDevice = this.allDevices.find(\n                        (d: any) => d.dsConfig.dSUID.toLowerCase() == id.toLowerCase(),\n                    );\n                    if (affectedDevice) {\n                        // found device -> storing current values into devicearray\n                        if (affectedDevice.deviceType == 'rgbLamp') {\n                            //  rgbLamp\n                            let key: string;\n                            let value: any;\n                            const sceneVals: any = {};\n                            // get the info on switchModeColor\n                            const SMC: any = await this.getForeignStateAsync(\n                                affectedDevice.watchStateID.switchModeColor,\n                            );\n                            for ([key, value] of Object.entries(affectedDevice.watchStateID)) {\n                                const state: any = await this.getForeignStateAsync(value);\n                                if (!affectedDevice.scenes) {\n                                    affectedDevice.scenes = [];\n                                }\n                                /* if (!affectedDevice.scenes[msg.scene]) {\n                                    affectedDevice.scenes[msg.scene] = {};\n                                } */\n                                // delete scene first\n                                let dC = false;\n\n                                switch (key) {\n                                    case 'colorTemp':\n                                        dC = SMC.val ? true : false;\n                                        break;\n                                    case 'hue':\n                                        dC = SMC.val ? false : true;\n                                        break;\n                                    case 'saturation':\n                                        dC = SMC.val ? false : true;\n                                        break;\n                                }\n                                sceneVals[key] = { value: state.val, dontCare: dC }; // TODO understand and make it dynamic\n\n                                /*this.log.debug(\n                                    `Set scene ${msg.scene} on key ${key} to value ${state.val} ::: ${JSON.stringify(\n                                        this.config.dsDevices,\n                                    )}`,\n                                );*/\n                            }\n                            affectedDevice.scenes = affectedDevice.scenes.filter((d: any) => d.sceneId != msg.scene);\n                            affectedDevice.scenes.push({ sceneId: msg.scene, values: sceneVals });\n                            this.log.debug(\n                                `Set scene ${msg.scene} on ${affectedDevice.name} ::: ${JSON.stringify(\n                                    this.allDevices,\n                                )}`,\n                            );\n                            // make it persistent by storing it back to the device\n                            await this.setObjectAsync(\n                                `digitalstrom-vdc.0.DS-Devices.configuredDevices.${affectedDevice.id}`,\n                                {\n                                    type: 'state',\n                                    common: {\n                                        name: affectedDevice.name,\n                                        type: 'boolean',\n                                        role: 'indicator',\n                                        read: true,\n                                        write: true,\n                                    },\n                                    native: {\n                                        deviceObj: affectedDevice,\n                                    },\n                                },\n                            ).then(async (success) => {\n                                this.log.debug(`Device created ${success}`);\n                                this.allDevices = await this.refreshDeviceList();\n                            });\n                        } else if (affectedDevice.deviceType == 'lamp') {\n                            // lamp -> store nothing since only power on / off is supported\n\n                            let key: string;\n                            let value: any;\n                            const sceneVals: any = {};\n\n                            for ([key, value] of Object.entries(affectedDevice.watchStateID)) {\n                                const state: any = await this.getForeignStateAsync(value);\n                                if (!affectedDevice.scenes) {\n                                    affectedDevice.scenes = [];\n                                }\n                                /* if (!affectedDevice.scenes[msg.scene]) {\n                                    affectedDevice.scenes[msg.scene] = {};\n                                } */\n                                // delete scene first\n                                const dC = false;\n\n                                sceneVals[key] = { value: state.val, dontCare: dC }; // TODO understand and make it dynamic\n\n                                /*this.log.debug(\n                                    `Set scene ${msg.scene} on key ${key} to value ${state.val} ::: ${JSON.stringify(\n                                        this.config.dsDevices,\n                                    )}`,\n                                );*/\n                            }\n\n                            affectedDevice.scenes = affectedDevice.scenes.filter((d: any) => d.sceneId != msg.scene);\n                            affectedDevice.scenes.push({ sceneId: msg.scene, values: sceneVals });\n                            this.log.debug(\n                                `Set scene ${msg.scene} on ${affectedDevice.name} ::: ${JSON.stringify(\n                                    this.allDevices,\n                                )}`,\n                            );\n                            // make it persistent by storing it back to the device\n                            await this.setObjectAsync(\n                                `digitalstrom-vdc.0.DS-Devices.configuredDevices.${affectedDevice.id}`,\n                                {\n                                    type: 'state',\n                                    common: {\n                                        name: affectedDevice.name,\n                                        type: 'boolean',\n                                        role: 'indicator',\n                                        read: true,\n                                        write: true,\n                                    },\n                                    native: {\n                                        deviceObj: affectedDevice,\n                                    },\n                                },\n                            ).then(async (success) => {\n                                this.log.debug(`Device created ${success}`);\n                                this.allDevices = await this.refreshDeviceList();\n                            });\n                        }\n                    }\n                });\n            }\n        });\n\n        vdc.on('VDSM_NOTIFICATION_CALL_SCENE', (msg: any) => {\n            this.log.info(`received call scene event ${JSON.stringify(msg)}`);\n            // search if the dsUID is known\n            if (msg && msg.dSUID) {\n                msg.dSUID.forEach((id: string) => {\n                    const affectedDevice = this.allDevices.find(\n                        (d: any) => d.dsConfig.dSUID.toLowerCase() == id.toLowerCase(),\n                    );\n                    if (affectedDevice) {\n                        // found a device\n                        if (affectedDevice.deviceType == 'lamp') {\n                            switch (msg.scene) {\n                                case 5:\n                                    // scene 14 called -> turn on in case of simple light\n                                    this.setForeignState(affectedDevice.watchStateID.light, true, false);\n                                    break;\n                                case 14:\n                                    // scene 14 called -> turn on in case of simple light\n                                    this.setForeignState(affectedDevice.watchStateID.light, true, false);\n                                    break;\n                                case 13:\n                                    // scene 13 called -> turn off in case of simple light\n                                    this.setForeignState(affectedDevice.watchStateID.light, false);\n                                    break;\n                                case 69:\n                                    // scene 69 sleep called -> turn off in case of simple light\n                                    this.setForeignState(affectedDevice.watchStateID.light, false);\n                                    break;\n                                case 72:\n                                    // scene 72 away called -> turn off in case of simple light\n                                    this.setForeignState(affectedDevice.watchStateID.light, false);\n                                    break;\n                                case 0:\n                                    // scene 0 called -> turn off in case of simple light\n                                    this.setForeignState(affectedDevice.watchStateID.light, false);\n                                    break;\n                                default:\n                                    const dScene = affectedDevice.scenes.find((s: any) => {\n                                        return s.sceneId == msg.scene;\n                                    });\n                                    if (dScene) {\n                                        // scene is defined... loop it and set all values\n                                        let key: any;\n                                        let value: any;\n                                        this.log.debug(\n                                            `looping the values inside scene ${msg.scene} -> ${JSON.stringify(dScene)}`,\n                                        );\n                                        for ([key, value] of Object.entries(dScene.values)) {\n                                            this.log.debug(\n                                                `performing update on state: ${key} ${JSON.stringify(\n                                                    affectedDevice.watchStateID,\n                                                )} with key ${key} value ${value.value}`,\n                                            );\n                                            // if (key == \"switch\") value.value = true; // set power state on\n                                            this.log.debug(\n                                                `setting ${value.value} of ${affectedDevice.name} to on ${affectedDevice.watchStateID[key]}`,\n                                            );\n                                            this.setForeignState(affectedDevice.watchStateID[key], value.value);\n                                        }\n                                    }\n                                    break;\n                            }\n                        } else if (affectedDevice.deviceType == 'rgbLamp') {\n                            this.log.debug(JSON.stringify(affectedDevice));\n                            if (msg.scene == '13') {\n                                // turn off power\n                                this.setForeignState(affectedDevice.watchStateID.switch, false);\n                            } else if (msg.scene == '0') {\n                                // turn off power\n                                this.setForeignState(affectedDevice.watchStateID.switch, false);\n                            } else if (msg.scene == '72') {\n                                // turn off power\n                                this.setForeignState(affectedDevice.watchStateID.switch, false);\n                            } else if (msg.scene == '69') {\n                                // turn off power\n                                this.setForeignState(affectedDevice.watchStateID.switch, false);\n                            } else if (affectedDevice.scenes) {\n                                const dScene = affectedDevice.scenes.find((s: any) => {\n                                    return s.sceneId == msg.scene;\n                                });\n                                if (dScene) {\n                                    // scene is defined... loop it and set all values\n                                    let key: any;\n                                    let value: any;\n                                    this.log.debug(\n                                        `looping the values inside scene ${msg.scene} -> ${JSON.stringify(dScene)}`,\n                                    );\n                                    for ([key, value] of Object.entries(dScene.values)) {\n                                        this.log.debug(\n                                            `performing update on state: ${key} ${JSON.stringify(\n                                                affectedDevice.watchStateID,\n                                            )} with key ${key} value ${value.value}`,\n                                        );\n                                        // if (key == \"switch\") value.value = true; // set power state on\n                                        this.log.debug(\n                                            `setting ${value.value} of ${affectedDevice.name} to on ${affectedDevice.watchStateID[key]}`,\n                                        );\n                                        this.setForeignState(affectedDevice.watchStateID[key], value.value);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n        });\n\n        vdc.on('channelStatesRequest', async (msg: any) => {\n            this.log.debug(`received request for status ${JSON.stringify(msg)}`);\n\n            // search if the dsUID is known\n            if (msg && msg.dSUID) {\n                const affectedDevice = this.allDevices.find(\n                    (d: any) => d.dsConfig.dSUID.toLowerCase() == msg.dSUID.toLowerCase(),\n                );\n                this.log.debug('FOUND DEVICE: ' + JSON.stringify(affectedDevice));\n                if (affectedDevice && affectedDevice.deviceType == 'lamp') {\n                    const state: any = await this.getForeignStateAsync(affectedDevice.watchStateID.light);\n                    // const state: any = await getFState(affectedDevice.watchStateID);\n                    this.log.info('msg value from state: ' + JSON.stringify(state));\n                    msg.value = state.val ? 100 : 0;\n                    this.log.info('msg value from state: ' + msg.value);\n                    vdc.sendState(msg.value, msg.messageId);\n                } else if (affectedDevice && affectedDevice.deviceType == 'rgbLamp') {\n                    msg.names.forEach(async (e: any) => {\n                        this.log.debug(`searching state on ${affectedDevice.name} for state ${e}`);\n                        let affectedState = affectedDevice.watchStateID[e];\n                        if (affectedState) {\n                            // this does not match rgb, since that is split in x & y\n                            this.log.debug(\n                                `Received request for status for device  ${affectedDevice.name} and state ${affectedState}`,\n                            );\n                            const state: any = await this.getForeignStateAsync(affectedState);\n                            this.log.debug('msg value from state: ' + JSON.stringify(state));\n                            const subElement = {\n                                name: e,\n                                elements: [{ name: 'value', value: { vDouble: state.val } }],\n                            };\n                            vdc.sendComplexState(msg.messageId, subElement);\n                        } else if (e == 'x' || e == 'y') {\n                            // special handling for x & y\n                            // get rgbstate\n                            affectedState = affectedDevice.watchStateID['rgb'];\n                            if (affectedState) {\n                                this.log.debug(`getting rgb value from ${affectedState}`);\n                                const state: any = await this.getForeignStateAsync(affectedState);\n                                this.log.debug(`got a state for rgb: ${JSON.stringify(state)}`);\n                                if (state) {\n                                    if (state.val.indexOf('#') == 0) {\n                                        state.val = state.val.substring(1);\n                                    } else {\n                                        // TODO yeelight adapter has a bug and stores the rgb value in dec instead of hex -> we need to convert it to hex first\n                                        state.val = parseInt(state.val).toString(16);\n                                    }\n                                    const rgb = rgbhelper.hexToRgb(state.val);\n                                    this.log.debug(\n                                        `did some math and got me some rgb from ${state.val} to ${JSON.stringify(rgb)}`,\n                                    );\n                                    if (rgb) {\n                                        const cie = rgbhelper.rgb_to_cie(rgb.r, rgb.g, rgb.b);\n                                        this.log.debug(\n                                            `did some more math and found me some CIE values from ${JSON.stringify(\n                                                rgb,\n                                            )} to ${cie}`,\n                                        );\n                                        let subElement = {};\n                                        switch (e) {\n                                            case 'x':\n                                                subElement = {\n                                                    name: 'x',\n                                                    elements: [{ name: 'value', value: { vDouble: cie[0] } }],\n                                                };\n                                                vdc.sendComplexState(msg.messageId, subElement);\n                                                break;\n                                            case 'y':\n                                                subElement = {\n                                                    name: 'y',\n                                                    elements: [{ name: 'value', value: { vDouble: cie[1] } }],\n                                                };\n                                                vdc.sendComplexState(msg.messageId, subElement);\n                                                break;\n                                        }\n                                    }\n                                }\n                            }\n                        } else {\n                            this.log.error(`The device ${affectedDevice.name} has no watchState for ${e}`);\n                        }\n                    });\n                } else if (affectedDevice && affectedDevice.deviceType == 'multiSensor') {\n                    const elements: Array<any> = [];\n                    for (const [key, value] of Object.entries(affectedDevice.watchStateID)) {\n                        const subState = await this.getForeignStateAsync(value as string);\n                        if (subState) {\n                            elements.push({\n                                name: key as string,\n                                elements: [\n                                    { name: 'age', value: { vDouble: 1 } },\n                                    { name: 'error', value: { vUint64: '0' } },\n                                    { name: 'value', value: { vDouble: subState.val } },\n                                ],\n                            });\n                        }\n                    }\n                    this.log.debug('Sending complex state ' + JSON.stringify(elements));\n                    vdc.sendComplexState(msg.messageId, elements);\n                } else if (affectedDevice && affectedDevice.deviceType == 'sensor') {\n                    const elements: Array<any> = [];\n                    for (const [key, value] of Object.entries(affectedDevice.watchStateID)) {\n                        const subState = await this.getForeignStateAsync(value as string);\n                        if (subState) {\n                            elements.push({\n                                name: key as string,\n                                elements: [\n                                    { name: 'age', value: { vDouble: 1 } },\n                                    { name: 'error', value: { vUint64: '0' } },\n                                    { name: 'value', value: { vDouble: subState.val } },\n                                ],\n                            });\n                        }\n                    }\n                    vdc.sendComplexState(msg.messageId, elements);\n                } else if (affectedDevice && affectedDevice.deviceType == 'presenceSensor') {\n                    const elements: Array<any> = [];\n                    for (const [key, value] of Object.entries(affectedDevice.watchStateID)) {\n                        const subState = await this.getForeignStateAsync(value as string);\n                        if (subState) {\n                            elements.push({\n                                name: key as string,\n                                elements: [\n                                    { name: 'age', value: { vDouble: 1 } },\n                                    { name: 'error', value: { vUint64: '0' } },\n                                    { name: 'value', value: { vBool: subState.val } },\n                                ],\n                            });\n                        }\n                    }\n                    vdc.sendComplexState(msg.messageId, elements);\n                } else {\n                    // send generic response\n                    vdc.sendState(msg.value, msg.messageId);\n                }\n            }\n        });\n\n        vdc.on('binaryInputStateRequest', async (msg: any) => {\n            this.log.info(`received request for binaryInputStateRequest ${JSON.stringify(msg)}`);\n\n            // search if the dsUID is known\n            if (msg && msg.dSUID) {\n                const affectedDevice = this.allDevices.find(\n                    (d: any) => d.dsConfig.dSUID.toLowerCase() == msg.dSUID.toLowerCase(),\n                );\n                this.log.debug(`found device ${JSON.stringify(affectedDevice)}`);\n                if (affectedDevice && affectedDevice.deviceType == 'presenceSensor') {\n                    // const state: any = await this.getForeignStateAsync(affectedDevice.watchStateID);\n                    // const state: any = await getFState(affectedDevice.watchStateID);\n                    // this.log.info(\"msg value from state: \" + JSON.stringify(state));\n                    // msg.value = state.val ? 1 : 0;\n                    // this.log.info(\"msg value from state: \" + msg.value);\n                    const inputStates: Array<any> = [];\n                    affectedDevice.dsConfig.binaryInputDescriptions.forEach((i: any) => {\n                        inputStates.push({\n                            name: i.objName,\n                            age: 1,\n                            value: null,\n                        });\n                    });\n                    vdc.sendBinaryInputState(inputStates, msg.messageId);\n                } else if (affectedDevice && affectedDevice.deviceType == 'smokeAlarm') {\n                    // const state: any = await this.getForeignStateAsync(affectedDevice.watchStateID);\n                    // const state: any = await getFState(affectedDevice.watchStateID);\n                    // this.log.info(\"msg value from state: \" + JSON.stringify(state));\n                    // msg.value = state.val ? 1 : 0;\n                    // this.log.info(\"msg value from state: \" + msg.value);\n                    const inputStates: Array<any> = [];\n                    affectedDevice.dsConfig.binaryInputDescriptions.forEach((i: any) => {\n                        inputStates.push({\n                            name: i.objName,\n                            age: 1,\n                            value: null,\n                        });\n                    });\n                    try {\n                        vdc.sendBinaryInputState(inputStates, msg.messageId);\n                    } catch (e: any) {\n                        this.log.error(JSON.stringify(e));\n                    }\n                }\n            }\n        });\n\n        vdc.on('sensorStatesRequest', async (msg: any) => {\n            // this.log.info(`received request for binaryInputStateRequest ${JSON.stringify(msg)}`);\n\n            // search if the dsUID is known\n            if (msg && msg.dSUID) {\n                const affectedDevice = this.allDevices.find(\n                    (d: any) => d.dsConfig.dSUID.toLowerCase() == msg.dSUID.toLowerCase(),\n                );\n                if (affectedDevice && affectedDevice.deviceType == 'sensor') {\n                    if (typeof affectedDevice.watchStateID == 'object') {\n                        // multiple sensors are defined\n                        const sensorStates: Array<any> = [];\n                        for (const [key, value] of Object.entries(affectedDevice.watchStateID)) {\n                            const state: any = await this.getForeignStateAsync(value as string);\n                            // const state: any = await getFState(affectedDevice.watchStateID);\n                            this.log.info('msg value from state: ' + JSON.stringify(state));\n\n                            if (\n                                affectedDevice.modifiers &&\n                                typeof affectedDevice.modifiers == 'object' &&\n                                key &&\n                                affectedDevice.modifiers[key as string]\n                            ) {\n                                state.val = (state.val as number) * parseFloat(affectedDevice.modifiers[key as string]);\n                            }\n\n                            sensorStates.push({\n                                name: key as string,\n                                age: 5,\n                                value: state.val,\n                            });\n                        }\n                        vdc.sendSensorStatesRequest(sensorStates, msg.messageId);\n                    } else {\n                        // only one sensor is defined\n                        const state: any = await this.getForeignStateAsync(affectedDevice.watchStateID);\n                        // const state: any = await getFState(affectedDevice.watchStateID);\n                        this.log.info('msg value from state: ' + JSON.stringify(state));\n                        const sensorStates: Array<any> = [];\n                        affectedDevice.dsConfig.sensorDescriptions.forEach((i: any) => {\n                            if (\n                                affectedDevice.modifiers &&\n                                typeof affectedDevice.modifiers == 'object' &&\n                                i.objName &&\n                                affectedDevice.modifiers[i.objName as string]\n                            ) {\n                                state.val =\n                                    (state.val as number) * parseFloat(affectedDevice.modifiers[i.objName as string]);\n                            }\n\n                            sensorStates.push({\n                                name: i.objName,\n                                age: 5,\n                                value: state.val,\n                            });\n                        });\n                        vdc.sendSensorStatesRequest(sensorStates, msg.messageId);\n                    }\n                    // msg.value = state.val ? 1 : 0;\n                    // this.log.info(\"msg value from state: \" + msg.value);\n                    // vdc.sendSensorStatesRequest('sensor_0', 15, 0.000686, msg.messageId);\n                } else if (affectedDevice && affectedDevice.deviceType == 'multiSensor') {\n                    // multiple sensors are defined\n                    const sensorStates: Array<any> = [];\n                    for (const [key, value] of Object.entries(affectedDevice.watchStateID)) {\n                        const state: any = await this.getForeignStateAsync(value as string);\n                        // const state: any = await getFState(affectedDevice.watchStateID);\n                        this.log.info('msg value from state: ' + JSON.stringify(state));\n\n                        if (\n                            affectedDevice.modifiers &&\n                            typeof affectedDevice.modifiers == 'object' &&\n                            key &&\n                            affectedDevice.modifiers[key as string]\n                        ) {\n                            state.val = (state.val as number) * parseFloat(affectedDevice.modifiers[key as string]);\n                        }\n\n                        sensorStates.push({\n                            name: key as string,\n                            age: 1,\n                            value: state.val,\n                        });\n                    }\n                    vdc.sendSensorStatesRequest(sensorStates, msg.messageId);\n                }\n            }\n        });\n\n        vdc.on('vdcRunningState', () => {\n            this.setStateAsync('DS-Devices.VDC.running', { val: true, ack: true });\n            this.log.info(`VDC <${this.config.vdcName}> is running on port ${this.config.vdcPort}`);\n        });\n\n        vdc.on('deviceZoneChange', (msg: any) => {\n            this.log.info(`deviceZoneChange event received with the following information ${JSON.stringify(msg)}`);\n        });\n\n        vdc.on('updateDeviceValues', async (msg: any) => {\n            this.log.info(`deviceUpdate received with the following information ${JSON.stringify(msg)}`);\n            const affectedDevice = this.allDevices.find(\n                (d: any) => d.dsConfig.dSUID.toLowerCase() == msg.dSUID.toLowerCase(),\n            );\n            if (affectedDevice) {\n                affectedDevice.dsConfig = msg;\n                await this.setObjectAsync(`digitalstrom-vdc.0.DS-Devices.configuredDevices.${affectedDevice.id}`, {\n                    type: 'state',\n                    common: {\n                        name: affectedDevice.name,\n                        type: 'boolean',\n                        role: 'indicator',\n                        read: true,\n                        write: true,\n                    },\n                    native: {\n                        deviceObj: affectedDevice,\n                    },\n                }).then(async (success) => {\n                    this.log.debug(`Device created ${success}`);\n                    this.allDevices = await this.refreshDeviceList();\n                });\n            }\n        });\n        this.setState('info.connection', true, true); // TODO check right place?\n    }\n\n    /**\n     * Is called when adapter shuts down - callback has to be called under any circumstances!\n     */\n    private onUnload(callback: () => void): void {\n        try {\n            // Here you must clear all timeouts or intervals that may still be active\n            // clearTimeout(timeout1);\n            // clearTimeout(timeout2);\n            // ...\n            // clearInterval(interval1);\n\n            // TODO end all connections and such here!!\n\n            callback();\n        } catch (e) {\n            callback();\n        }\n    }\n\n    // If you need to react to object changes, uncomment the following block and the corresponding line in the constructor.\n    // You also need to subscribe to the objects with `this.subscribeObjects`, similar to `this.subscribeStates`.\n    // /**\n    //  * Is called if a subscribed object changes\n    //  */\n    // private onObjectChange(id: string, obj: ioBroker.Object | null | undefined): void {\n    // \tif (obj) {\n    // \t\t// The object was changed\n    // \t\tthis.log.info(`object ${id} changed: ${JSON.stringify(obj)}`);\n    // \t} else {\n    // \t\t// The object was deleted\n    // \t\tthis.log.info(`object ${id} deleted`);\n    // \t}\n    // }\n\n    /**\n     * private function used to fill the alldevices array\n     * @private\n     */\n    private async refreshDeviceList(): Promise<any> {\n        interface GetObjectViewItem {\n            /** The ID of this object */\n            id: string;\n            /** A copy of the object from the DB */\n            value: ioBroker.Object | null;\n        }\n        return await this.getObjectViewAsync('digitalstrom-vdc', 'listDevicesFullObj', {\n            startkey: 'digitalstrom-vdc.' + this.instance + '.',\n            endkey: 'digitalstrom-vdc.' + this.instance + '.\\u9999',\n        }).then((doc: { rows: GetObjectViewItem[] }) => {\n            if (doc && doc.rows) {\n                const aD: any = [];\n                for (let i = 0; i < doc.rows.length; i++) {\n                    const id = doc.rows[i].id;\n                    const obj: any = doc.rows[i].value;\n                    if (obj && Object.keys(obj).length > 0) {\n                        if (\n                            obj.deviceObj &&\n                            typeof obj.deviceObj == 'object' &&\n                            Object.keys(obj.deviceObj).length > 0\n                        ) {\n                            // TODO check old code: if (obj.deviceObj.dsConfig) {\n                            this.log.debug('Found ' + id + ': ' + JSON.stringify(obj.deviceObj));\n                            aD.push(obj.deviceObj);\n                        }\n                    }\n                }\n                if (!doc.rows.length) console.log('No objects found.');\n                this.log.debug('AD: ' + JSON.stringify(aD));\n                return aD;\n            } else {\n                console.log('No objects found: ');\n                return [];\n            }\n        });\n    }\n\n    // If you need to react to object changes, uncomment the following block and the corresponding line in the constructor.\n    // You also need to subscribe to the objects with `this.subscribeObjects`, similar to `this.subscribeStates`.\n    // /**\n    //  * Is called if a subscribed object changes\n    //  */\n    private onObjectChange(id: string, obj: ioBroker.Object | null | undefined): void {\n        if (obj) {\n            // The object was changed\n            this.log.info(`object ${id} changed: ${JSON.stringify(obj)}`);\n        } else {\n            // The object was deleted\n            this.log.info(`object ${id} deleted`);\n        }\n    }\n\n    private async replyMultiSensor(affectedDevice: any): Promise<void> {\n        const elements: Array<any> = [];\n        for (const [key, value] of Object.entries(affectedDevice.watchStateID)) {\n            const subState = await this.getForeignStateAsync(value as string);\n            if (subState) {\n                elements.push({\n                    name: key as string,\n                    elements: [\n                        { name: 'age', value: { vDouble: 10 } },\n                        { name: 'error', value: { vUint64: '0' } },\n                        { name: 'value', value: { vDouble: subState.val } },\n                    ],\n                });\n            }\n        }\n        this.vdc.sendUpdate(affectedDevice.dsConfig.dSUID, [\n            {\n                name: 'sensorStates',\n                elements: elements,\n            },\n        ]);\n    }\n\n    /**\n     * Is called if a subscribed state changes\n     */\n    private onStateChange(id: string, state: ioBroker.State | null | undefined): void {\n        try {\n            if (state) {\n                // The state was changed\n                this.log.info(`state ${id} changed: ${state.val} (ack = ${state.ack})`);\n\n                // inform vdc\n                const affectedDevice = this.allDevices.find(\n                    (d: any) =>\n                        d.native.deviceObj.watchStateID == id ||\n                        Object.values(d.native.deviceObj.watchStateID).indexOf(id) > -1,\n                );\n                if (affectedDevice && typeof affectedDevice.watchStateID == 'object') {\n                    const updateName = Object.keys(affectedDevice.watchStateID).find(\n                        (key) => affectedDevice.watchStateID[key] === id,\n                    );\n                    if (affectedDevice.deviceType == 'multiSensor') {\n                        // this.replyMultiSensor(affectedDevice);\n                        if (\n                            affectedDevice.modifiers &&\n                            typeof affectedDevice.modifiers == 'object' &&\n                            updateName &&\n                            affectedDevice.modifiers[updateName]\n                        ) {\n                            state.val = (state.val as number) * parseFloat(affectedDevice.modifiers[updateName]);\n                        }\n                        this.vdc.sendUpdate(affectedDevice.dsConfig.dSUID, [\n                            {\n                                name: 'sensorStates',\n                                elements: [\n                                    {\n                                        name: updateName,\n                                        elements: [\n                                            { name: 'age', value: null },\n                                            { name: 'error', value: { vUint64: '0' } },\n                                            { name: 'value', value: { vDouble: state.val } },\n                                        ],\n                                    },\n                                ],\n                            },\n                        ]);\n                    } else if (affectedDevice.deviceType == 'sensor') {\n                        if (\n                            affectedDevice.modifiers &&\n                            typeof affectedDevice.modifiers == 'object' &&\n                            updateName &&\n                            affectedDevice.modifiers[updateName]\n                        ) {\n                            state.val = (state.val as number) * parseFloat(affectedDevice.modifiers[updateName]);\n                        }\n                        this.vdc.sendUpdate(affectedDevice.dsConfig.dSUID, [\n                            {\n                                name: 'sensorStates',\n                                elements: [\n                                    {\n                                        name: updateName,\n                                        elements: [\n                                            { name: 'age', value: { vDouble: 0.1 } },\n                                            { name: 'error', value: { vUint64: '0' } },\n                                            { name: 'value', value: { vDouble: state.val } },\n                                        ],\n                                    },\n                                ],\n                            },\n                        ]);\n                    } else if (affectedDevice.deviceType == 'presenceSensor') {\n                        const newState = state.val ? 1 : 0;\n                        this.vdc.sendUpdate(affectedDevice.dsConfig.dSUID, [\n                            {\n                                name: 'binaryInputStates',\n                                elements: [\n                                    {\n                                        name: updateName,\n                                        elements: [\n                                            { name: 'age', value: { vDouble: 1 } },\n                                            { name: 'error', value: { vUint64: '0' } },\n                                            { name: 'value', value: { vBool: newState } },\n                                        ],\n                                    },\n                                ],\n                            },\n                        ]);\n                    } else if (affectedDevice.deviceType == 'smokeAlarm') {\n                        const newState = state.val ? 1 : 0;\n                        this.vdc.sendUpdate(affectedDevice.dsConfig.dSUID, [\n                            {\n                                name: 'binaryInputStates',\n                                elements: [\n                                    {\n                                        name: updateName,\n                                        elements: [\n                                            { name: 'age', value: { vDouble: 1 } },\n                                            { name: 'error', value: { vUint64: '0' } },\n                                            { name: 'value', value: { vBool: newState } },\n                                        ],\n                                    },\n                                ],\n                            },\n                        ]);\n                    } else if (affectedDevice.deviceType == 'button') {\n                        // const newState = state.val ? 1 : 0;\n                        this.vdc.sendUpdate(affectedDevice.dsConfig.dSUID, [\n                            {\n                                name: 'buttonInputStates',\n                                elements: [\n                                    {\n                                        name: updateName,\n                                        elements: [\n                                            { name: 'age', value: { vDouble: 1 } },\n                                            { name: 'clickType', value: { vUint64: 0 } },\n                                            { name: 'error', value: { vUint64: '0' } },\n                                            { name: 'value', value: { vBool: 0 } },\n                                        ],\n                                    },\n                                ],\n                            },\n                        ]);\n                    } else if (affectedDevice.deviceType == 'awayButton') {\n                        // const newState = state.val ? 1 : 0;\n                        this.vdc.sendUpdate(affectedDevice.dsConfig.dSUID, [\n                            {\n                                name: 'buttonInputStates',\n                                elements: [\n                                    {\n                                        name: updateName,\n                                        elements: [\n                                            { name: 'age', value: { vDouble: 1 } },\n                                            { name: 'clickType', value: { vUint64: 4 } },\n                                            { name: 'error', value: { vUint64: '0' } },\n                                            { name: 'value', value: { vBool: 0 } },\n                                        ],\n                                    },\n                                ],\n                            },\n                        ]);\n                        setTimeout(() => {\n                            this.vdc.sendUpdate(affectedDevice.dsConfig.dSUID, [\n                                {\n                                    name: 'buttonInputStates',\n                                    elements: [\n                                        {\n                                            name: updateName,\n                                            elements: [\n                                                { name: 'age', value: { vDouble: 1 } },\n                                                { name: 'clickType', value: { vUint64: 6 } },\n                                                { name: 'error', value: { vUint64: '0' } },\n                                                { name: 'value', value: { vBool: 0 } },\n                                            ],\n                                        },\n                                    ],\n                                },\n                            ]);\n                        }, 3.5 * 1000);\n                    } else if (affectedDevice.deviceType == 'doorbell') {\n                        // const newState = state.val ? 1 : 0;\n                        if (state.val) {\n                            // send event only if val is true\n                            this.vdc.sendUpdate(affectedDevice.dsConfig.dSUID, [\n                                {\n                                    name: 'buttonInputStates',\n                                    elements: [\n                                        {\n                                            name: updateName,\n                                            elements: [\n                                                { name: 'age', value: { vDouble: 1 } },\n                                                { name: 'clickType', value: { vUint64: 0 } },\n                                                { name: 'error', value: { vUint64: '0' } },\n                                                { name: 'value', value: { vBool: 0 } },\n                                            ],\n                                        },\n                                    ],\n                                },\n                            ]);\n                        }\n                    }\n                }\n            } else {\n                // The state was deleted\n                this.log.info(`state ${id} deleted`);\n            }\n        } catch (error) {\n            let message = error;\n            if (error instanceof Error && error.stack != null) message = error.stack;\n            this.log.error(`[onStateChange] ${message}`)\n        }\n    }\n\n    // If you need to accept messages in your adapter, uncomment the following block and the corresponding line in the constructor.\n    // /**\n    //  * Some message was sent to this instance over message box. Used by email, pushover, text2speech, ...\n    //  * Using this method requires \"common.messagebox\" property to be set to true in io-package.json\n    //  */\n    private async onMessage(obj: ioBroker.Message): Promise<void> {\n        const respond = (response: any): void => {\n            if (obj.callback) this.sendTo(obj.from, obj.command, response, obj.callback);\n        };\n        // some predefined responses so we only have to define them once\n        const responses = {\n            ACK: { error: null },\n            OK: { error: null, result: 'ok' },\n            ERROR_UNKNOWN_COMMAND: { error: 'Unknown command!' },\n            MISSING_PARAMETER: (paramName: string) => {\n                return { error: 'missing parameter \"' + paramName + '\"!' };\n            },\n            COMMAND_ACTIVE: { error: 'command already active' },\n            RESULT: (result: unknown) => ({ error: null, result }),\n            ERROR: (error: string) => ({ error }),\n        };\n        this.log.debug(`received onMessage ${JSON.stringify(obj)}`);\n        if (typeof obj === 'object') {\n            switch (obj.command) {\n                case 'addNewDevice': {\n                    this.log.debug('Add devices command received ' + JSON.stringify(obj));\n                    try {\n                        const deviceObj = obj.message as any;\n                        this.log.debug(JSON.stringify(deviceObj));\n                        this.setObjectNotExistsAsync(`DS-Devices.configuredDevices.${deviceObj.id}`, {\n                            type: 'state',\n                            common: {\n                                name: deviceObj.name,\n                                type: 'boolean',\n                                role: 'indicator',\n                                read: true,\n                                write: true,\n                            },\n                            native: {\n                                deviceObj,\n                            },\n                        });\n                        await this.setStateAsync(`DS-Devices.configuredDevices.${deviceObj.id}`, true);\n                        this.allDevices = await this.refreshDeviceList();\n                        return respond(responses.OK);\n                        //\n                    } catch (err: any) {\n                        console.error('Error while parsing object', err);\n                        return respond(responses.ERROR(err));\n                    }\n                }\n                case 'VanishDevice': {\n                    this.log.info(`sendVanishDevice command receveid for device ${obj.message}`);\n                    break;\n                }\n                case 'ListDevices': {\n                    this.allDevices = await this.refreshDeviceList();\n                    this.log.debug(`allDevices sendToListDevices - ${JSON.stringify(this.allDevices)}`);\n                    return respond(responses.RESULT(this.allDevices));\n                }\n                case 'RemoveDevice': {\n                    this.log.debug(`Remove device for ${JSON.stringify(obj.message)} received`);\n                    const deviceObj = obj.message as any;\n                    this.log.debug(`removing ${deviceObj._id}`);\n                    await this.delObject(deviceObj._id as string);\n                    this.log.debug(`Device ${JSON.stringify(obj.message)} successfully removed`);\n                    // if (deviceObj.dSUID) this.vdc.sendVanish(deviceObj.dSUID as string);\n                    this.allDevices = await this.refreshDeviceList();\n                    return respond(responses.OK);\n                }\n            }\n            // \t\tif (obj.command === 'send') {\n            // \t\t\t// e.g. send email or pushover or whatever\n            // \t\t\tthis.log.info('send command');\n            // \t\t\t// Send response in callback if required\n            // \t\t\tif (obj.callback) this.sendTo(obj.from, obj.command, 'Message received', obj.callback);\n            // \t\t}\n            /* TODO check old stuff from other brancch!\n\n\t\t\t            if (obj.command === \"send\") {\n                // e.g. send email or pushover or whatever\n                this.log.info(\"send command\");\n\n                // Send response in callback if required\n                if (obj.callback) this.sendTo(obj.from, obj.command, \"Message received\", obj.callback);\n            }\n            if (obj.command === \"genSDUID\") {\n                this.log.info(\"genSDUID command receveid\");\n                if (obj.callback) this.sendTo(obj.from, obj.command, \"Message received\", obj.callback);\n            }\n\n            if (obj.command === \"getRunning\") {\n                // this.log.info(\"getRunning command received\");\n                this.getState(\"DS-Devices.VDC.running\", (error, state) => {\n                    //this.log.info(JSON.stringify(state));\n                    // this.log.info(JSON.stringify(obj));\n                    if (obj.callback) this.sendTo(obj.from, obj.command, { state }, obj.callback);\n                });\n            }\n\n            if (obj.command === \"sendVanishDevice\") {\n                this.log.info(`sendVanishDevice command receveid for device ${obj.message}`);\n            }\n\n            if (obj.command === \"sendListDevices\") {\n                this.log.info(`sendListDevices command receveid`);\n                /* this.getStates(\"DS-Devices.configuredDevices.*\", (error, devices) => {\n                    this.log.debug(`the following devices are configured on the system ${JSON.stringify(devices)}`);\n                    if (obj.callback) this.sendTo(obj.from, obj.command, { devices }, obj.callback);\n                }); */\n            /*\n\t\t\tif (obj.callback) this.sendTo(obj.from, obj.command, this.allDevices, obj.callback);\n\t\t}\n\n\t\tif (obj.command === \"sendRemoveDevice\") {\n\t\t\tthis.log.debug(`Remove device for ${JSON.stringify(obj.message)} received`);\n\t\t\tconst deviceObj = obj.message as any;\n\t\t\tthis.delObject(`DS-Devices.configuredDevices.${deviceObj.id as string}`, async (error: any) => {\n\t\t\t\tthis.log.debug(`Device ${JSON.stringify(obj.message)} successfully with message ${error} removed`);\n\t\t\t\tthis.log.debug(JSON.stringify(deviceObj));\n\t\t\t\tif (obj.callback) this.sendTo(obj.from, obj.command, {}, obj.callback);\n\n\t\t\t\tif (deviceObj.dSUID) this.vdc.sendVanish(deviceObj.dSUID as string);\n\t\t\t\tthis.allDevices = await this.refreshDeviceList();\n\t\t\t});\n\t\t}\n\n\t\tif (obj.command === \"sendAddDevice\") {\n\t\t\tthis.log.debug(\"Add devices command received \" + JSON.stringify(obj));\n\t\t\ttry {\n\t\t\t\tconst deviceObj = obj.message as any;\n\t\t\t\tthis.log.debug(JSON.stringify(deviceObj));\n\t\t\t\tthis.setObjectNotExistsAsync(`DS-Devices.configuredDevices.${deviceObj.id}`, {\n\t\t\t\t\ttype: \"state\",\n\t\t\t\t\tcommon: {\n\t\t\t\t\t\tname: deviceObj.name,\n\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\trole: \"indicator\",\n\t\t\t\t\t\tread: true,\n\t\t\t\t\t\twrite: true,\n\t\t\t\t\t},\n\t\t\t\t\tnative: {\n\t\t\t\t\t\tdeviceObj,\n\t\t\t\t\t},\n\t\t\t\t}).then(async (success) => {\n\t\t\t\t\tthis.log.debug(`Device created ${success}`);\n\t\t\t\t\tawait this.setStateAsync(`DS-Devices.configuredDevices.${deviceObj.id}`, true);\n\t\t\t\t\tif (obj.callback) this.sendTo(obj.from, obj.command, { deviceObj }, obj.callback);\n\t\t\t\t\tthis.allDevices = await this.refreshDeviceList();\n\t\t\t\t});\n\t\t\t} catch (err) {\n\t\t\t\tconsole.error(\"Error while parsing object\", err);\n\t\t\t}\n\t\t}\n\t\t\t */\n        }\n    }\n}\n\nif (require.main !== module) {\n    // Export the constructor in compact mode\n    module.exports = (options: Partial<utils.AdapterOptions> | undefined) => new DigitalstromVdc(options);\n} else {\n    // otherwise start the instance directly\n    (() => new DigitalstromVdc())();\n}\n"],
  "mappings": "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",
  "names": []
}
